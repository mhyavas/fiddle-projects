{"version":3,"sources":["hyperfiddle/electric/impl/lang.cljs"],"mappings":";AAIA,AACA,AACA,AACA,AACA,AACA,AACA;;;uCAAA,wCAAA,4DAAA,kDAAA,yDAAA,8DAAA,2DAAA,2DAAA,0DAAA,6DAAA,yEAAA,iEAAA,3qBACEA,+qBAAW,WAAKC,OAAOC,MAAMC;AAAlB,AAAwB,8CAAA,vCAACC;GADtC,IAAA,IAAA,IAAA,IAAA,AAAA,iCAAA,AAAA,sHAAA;AAAA,AAAA;GAAA;AAKA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AAEA,AAAA,+CAAA,uDAAAC,tGAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,kFAAAF;;;AAAA,AAAA,CAAA,oFAAA,pFAAME,+FAAiBI;AAAvB,AACE,MAAO,gDAAA,+DAAA,2CAAA,1JAACC,+MAA8ED;;;AADxF,CAAA,uEAAA,vEAAMJ;;AAAN;AAAA,CAAA,iEAAA,WAAAC,5EAAMD;AAAN,AAAA,IAAAE,qBAAA;AAAA,AAAA,OAAAA,wDAAA,AAAAC,cAAAF;;;AAAA","names":["hyperfiddle.electric.impl.lang/trace","_frame","_vars","_env","hyperfiddle.electric.impl.runtime/pure","var_args","args__5728__auto__","len__5722__auto__","i__5723__auto__","argseq__5729__auto__","cljs.core/IndexedSeq","hyperfiddle.electric.impl.lang/electric-only","seq48340","self__5708__auto__","cljs.core/seq","args","cljs.core.ex_info"],"sourcesContent":["(ns hyperfiddle.electric.impl.lang\r\n  (:require [hyperfiddle.electric.impl.runtime :as r])\r\n  (:require-macros [hyperfiddle.electric.impl.lang]))\r\n\r\n(def ^{::type ::node, :doc \"for loop/recur impl\"} rec)\r\n(def ^{::type ::node, :doc \"for runtime arity check\"} %arity)\r\n(def ^{::type ::node, :doc \"for runtime varargs\"} %args)\r\n(def ^{::type ::node, :doc \"for self-recur\"} %closure)\r\n(def ^{::type ::node, :doc \"for try/catch\"} exception)\r\n(def ^{::type ::node, :doc \"for case\"} %case-test)\r\n(def ^{::type ::node, :doc \"In a `catch` block, bound by the runtime to the current stacktrace. An Electric stacktrace is an ExceptionInfo. Use `hyperfiddle.electric.debug/stack-trace` to get a string representation.\"}\r\n  trace {:fn (fn [_frame _vars _env] (r/pure nil)),\r\n         :get-used-nodes #(), :var-name `trace\r\n         :noutput 0, :ninput 0, :nvariable 0, :nsource 0, :ntarget 0, :dynamic '[], :nconstant 0})\r\n\r\n(def ^{::type ::node} %0)\r\n(def ^{::type ::node} %1)\r\n(def ^{::type ::node} %2)\r\n(def ^{::type ::node} %3)\r\n(def ^{::type ::node} %4)\r\n(def ^{::type ::node} %5)\r\n(def ^{::type ::node} %6)\r\n(def ^{::type ::node} %7)\r\n(def ^{::type ::node} %8)\r\n(def ^{::type ::node} %9)\r\n(def ^{::type ::node} %10)\r\n(def ^{::type ::node} %11)\r\n(def ^{::type ::node} %12)\r\n(def ^{::type ::node} %13)\r\n(def ^{::type ::node} %14)\r\n(def ^{::type ::node} %15)\r\n(def ^{::type ::node} %16)\r\n(def ^{::type ::node} %17)\r\n(def ^{::type ::node} %18)\r\n(def ^{::type ::node} %19)\r\n\r\n(defn electric-only [& args]\r\n  (throw (ex-info \"I'm an electric value and you called me outside of electric.\" {:args args})))\r\n"],"x_google_ignoreList":[0]}