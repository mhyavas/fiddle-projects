{"version":3,"sources":["contrib/data.cljc"],"mappings":"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","names":["js/Error","contrib.data/qualify","ns","?kw","cljs.core/Keyword","cljs.core/qualified-keyword?","cljs.core.keyword","cljs.core/name","contrib.data/unqualify","?qualified-kw","contrib.data/-omit-keys-ns","?m","cljs.core/reduce-kv","m","k","v","cljs.core._EQ_","cljs.core/namespace","cljs.core.assoc","contrib.data/has-ns?","named","cljs.core/simple-ident?","contrib.data/select-ns","map","cljs.core.into","cljs.core/empty","cljs.core.filter","p__43903","vec__43905","cljs.core.nth","_v","contrib.data/-auto-props","props","defaults-qualified","cljs.core/Symbol","cljs.core.merge","cljs.core/update-keys","cljs.core.partial","var_args","args__5728__auto__","len__5722__auto__","i__5723__auto__","argseq__5729__auto__","cljs.core/IndexedSeq","contrib.data/xorxs","p__43920","vec__43921","seq43917","G__43918","cljs.core/first","cljs.core/next","self__5707__auto__","xorxs","zero","cljs.core/vector?","cljs.core/set?","cljs.core/seq?","cljs.core.conj","or__4998__auto__","contrib.data/index-by","kf","xs","cljs.core.map_indexed","i","x","contrib.data/index","cljs.core/sequential?","contrib.data/group-by-pred","f?","map__43931","cljs.core/--destructure-map","cljs.core.get","a","b","cljs.core/group-by","contrib.data/update-existing","seq43933","G__43934","G__43935","G__43936","f","args","cljs.core.apply","cljs.core/update","contrib.data/take-upto","pred","rf","ac","nx","G__43967","cljs.core/ensure-reduced","contrib.data/round-floor","n","base","cljs.math/floor","G__43971","contrib.data/pad","coll","cljs.core.concat","cljs.core.repeat","cljs.core.take","contrib.data.pad","contrib.data/padl","cljs.core/count","contrib.data/assoc-vec","cljs.core/vec","contrib.data/padl-str","s","cljs.core/str","contrib.data/with-pad","reducer","cols","cljs.core/max","cljs.core.map","p1__43984#","contrib.data/map-pad","cljs.core/map","contrib.data/str-last-n","cljs.core/reverse","contrib.data/nil-or-empty?","cljs.core/seqable?","cljs.core/empty?","contrib.data/-tree-list","depth","children-fn","keep?","input","cljs.core.eduction","cljs.core.mapcat","clojure.datafy/datafy","temp__5814__auto__","children","temp__5816__auto__","rows","cljs.core/seq","G__44000","G__44001","G__44002","G__44003","G__44004","G__44007","G__44009","contrib.data/treelister","contrib.data.treelister","_"],"sourcesContent":["(ns contrib.data\r\n  (:require clojure.math\r\n            [clojure.datafy :refer [datafy]] ; todo remove\r\n            [hyperfiddle.rcf :refer [tests]])\r\n  #?(:cljs (:require-macros [contrib.data :refer [auto-props]])))\r\n\r\n(defn qualify\r\n  \"Qualify a keyword with a namespace. If already qualified, leave kw untouched. Nil-safe.\r\n  (qualify :db :isComponent) -> :db/isComponent\"\r\n  [ns ?kw]\r\n  {:pre [(some? ns) #_(not (namespace ns)) (keyword? ?kw)]}\r\n  (when ?kw\r\n    (if (qualified-keyword? ?kw)\r\n      ?kw (keyword (name ns) (name ?kw)))))\r\n\r\n(tests\r\n  ;(keyword (name (namespace ::ns)) (name :limit))\r\n  (qualify (namespace ::x) :limit) := ::limit\r\n  ;(qualify (namespace ::x) \"limit\") thrown? AssertionError\r\n  \"leave qualified kws untouched\"\r\n  (qualify (namespace ::x) :user/foo) := :user/foo)\r\n\r\n(defn unqualify\r\n  \"Strip namespace from keyword, discarding it and return unqualified keyword. Nil-safe.\r\n  (unqualify :db.type/ref) -> :ref\"\r\n  [?qualified-kw]\r\n  (assert (or (nil? ?qualified-kw)\r\n              (qualified-keyword? ?qualified-kw)) (str \" can't unqualify: \" ?qualified-kw))\r\n  (if ?qualified-kw\r\n    (keyword (name ?qualified-kw))))\r\n\r\n(tests\r\n  (unqualify ::x) := :x\r\n  (unqualify :db.type/ref) := :ref\r\n  (unqualify nil) := nil\r\n  (unqualify \"\") :throws #?(:clj AssertionError :cljs js/Error))\r\n\r\n(defn -omit-keys-ns [ns ?m]\r\n  {:pre [(some? ns)]}\r\n  (when ?m\r\n    (reduce-kv (fn [m k v] (if (= (name ns) (namespace k))\r\n                             m (assoc m k v))) {} ?m)))\r\n\r\n(defmacro omit-keys-ns\r\n  ([?m] `(-omit-keys-ns ~(str *ns*) ~?m))\r\n  ([ns- ?m] `(-omit-keys-ns ~ns- ~?m)))\r\n\r\n(tests\r\n  (omit-keys-ns :c {::a 1 :b 2 :c/c 3}) := {::a 1 :b 2}\r\n  (omit-keys-ns :c {::a 1 :b 2 :c/c 3}) := {::a 1 :b 2}\r\n  (omit-keys-ns :c nil) := nil\r\n  (omit-keys-ns nil {::a 1 :b 2 :c/c 3}) :throws #?(:clj AssertionError :cljs js/Error)\r\n  (omit-keys-ns nil nil) :throws #?(:clj AssertionError :cljs js/Error)\r\n  nil)\r\n\r\n(defn has-ns?\r\n  \"State if a `named` value (keyword or symbol) has such namespace `ns`.\r\n  `ns` can be be a string, or a non-namespaced keyword or symbol.\"\r\n  [ns named]\r\n  {:pre [(or (string? ns) (simple-ident? ns))]}\r\n  (= (name ns) (namespace named)))\r\n\r\n(defn select-ns\r\n  \"Like `select-keys` but select all namespaced keys by ns.\"\r\n  [ns map]\r\n  (into (empty map) (filter (fn [[k _v]] (has-ns? ns k))) map))\r\n\r\n(defn -auto-props \"qualify any unqualified keys to the current ns and then add qualified defaults\"\r\n  [ns props defaults-qualified]\r\n  {:pre [(some? ns) (or (string? ns) (symbol? ns))]}\r\n  (merge defaults-qualified (update-keys props (partial qualify ns))))\r\n\r\n(defmacro auto-props\r\n  ([ns props defaults-qualified] `(-auto-props ~ns ~props ~defaults-qualified))\r\n  ([props defaults-qualified] `(-auto-props ~(str *ns*) ~props ~defaults-qualified))\r\n  ([props] `(-auto-props ~(str *ns*) ~props {})))\r\n\r\n(tests\r\n  (auto-props \"user\" {:a 1} {:dom/class \"a\"}) := {:user/a 1 :dom/class \"a\"}\r\n  (auto-props 'user {:a 1} {:dom/class \"a\"}) := {:user/a 1 :dom/class \"a\"}\r\n  (auto-props *ns* {:a 1} {:dom/class \"a\"}) :throws #?(:clj AssertionError :cljs js/Error)\r\n  (auto-props {:a 1} {:dom/class \"a\"}) := {:contrib.data/a 1 :dom/class \"a\"}\r\n  (auto-props {:a 1}) := {:contrib.data/a 1})\r\n\r\n(defn xorxs\r\n  \"an argument parser that accepts both scalars and collections, lifting scalars into a collection\"\r\n  [xorxs & [zero]]\r\n  (cond (vector? xorxs) xorxs\r\n        (set? xorxs) xorxs\r\n        (seq? xorxs) xorxs\r\n        (nil? xorxs) zero\r\n        :else-single-value-or-map (conj (or zero []) xorxs)))\r\n\r\n(tests\r\n  (xorxs :a)     := [:a]\r\n  (xorxs [:a])   := [:a]\r\n  (xorxs #{:a})  := #{:a}\r\n  (xorxs :a #{}) := #{:a}\r\n  (xorxs :a [])  := [:a]\r\n  (xorxs nil #{}) := #{}\r\n  (xorxs nil) := nil)\r\n\r\n(defn index-by [kf xs]\r\n  {:pre [kf]}\r\n  (into {} (map-indexed (fn [i x]\r\n                          [(kf x i) ; fallback to index when key is not present\r\n                           #_(if-not kf (kf x i) i) ; alternative design is to define nil kf as fallback\r\n                           x])) xs))\r\n\r\n(tests\r\n  (def xs [{:db/ident :foo :a 1}\r\n           {:db/ident :bar :b 2}])\r\n\r\n  (index-by :db/ident xs)\r\n  := {:foo {:db/ident :foo, :a 1},\r\n         :bar {:db/ident :bar, :b 2}}\r\n\r\n  (index-by ::missing xs) ; should this throw?\r\n  := {0 {:db/ident :foo, :a 1},\r\n      1 {:db/ident :bar, :b 2}}\r\n\r\n  ;\"nil kf uses default value (which is likely unintended, should it throw?)\"\r\n  ;(index-by nil xs)\r\n  ;:= {0 {:db/ident :foo, :a 1},\r\n  ;    1 {:db/ident :bar, :b 2}}\r\n\r\n  (index-by :a nil) := {}\r\n  ;(index-by nil nil) := {} ; kf never used -- alternative design\r\n  (index-by nil nil) :throws #?(:clj AssertionError :cljs js/Error)\r\n\r\n  (index-by :a [{}]) := {0 {}}\r\n  (index-by :a [{:a 1}]) := {1 {:a 1}}\r\n  (index-by :b [{:a 1}]) := {0 {:a 1}} ; missing key, fallback to index\r\n\r\n  \"indexing map entries (which is weird, should this throw?)\"\r\n  (index-by :a {:a 1}) := {0 [:a 1]} ; index the map entry, not the map, :a is missing so fallback\r\n  (index-by :b {:a 1}) := {0 [:a 1]}\r\n\r\n  \"collisions are possible\"\r\n  (index-by :db/id [{:db/id 1} {:db/id 2} {:db/id 1}]) ; should this detect collision and throw?\r\n  := {1 #:db{:id 1}, 2 #:db{:id 2}}\r\n\r\n  \"kf fallback arity\"\r\n  (index-by (fn [x i] (str i)) xs)\r\n  := {\"0\" {:db/ident :foo, :a 1},\r\n      \"1\" {:db/ident :bar, :b 2}}\r\n\r\n  \"index by first element\"\r\n  ;(index-by first [[:a 1] [:b 2]]) -- ArityException: kf must accept fallback. Is this a mistake?\r\n  (index-by (fn [a b] (first a)) [[:a 1] [:b 2]]) := {:a [:a 1], :b [:b 2]}\r\n  (index-by #(do %2 (first %1)) [[:a 1] [:b 2]]) := {:a [:a 1], :b [:b 2]})\r\n\r\n(defn index\r\n  \"index a sequential collection into an associative collection with explicit keys. this may not be\r\n  useful, as vectors are already associative\"\r\n  [xs]\r\n  (assert (sequential? xs)) ; maps are not indexable\r\n  (index-by (fn [x i] i) xs))\r\n\r\n(tests\r\n  (def xs [{:db/ident :foo :a 1}\r\n           {:db/ident :bar :b 2}])\r\n  (index xs)\r\n  := {0 {:db/ident :foo, :a 1},\r\n      1 {:db/ident :bar, :b 2}})\r\n\r\n(defn group-by-pred [f? xs] ; todo rename\r\n  (let [{a true b false} (group-by f? xs)]\r\n    [a b]))\r\n\r\n(tests\r\n  (group-by-pred map? [:user/email\r\n                       {:user/gender [:db/ident]}\r\n                       {:user/shirt-size [:db/ident]}\r\n                       :db/id])\r\n  := [[#:user{:gender [:db/ident]}\r\n       #:user{:shirt-size [:db/ident]}]\r\n      [:user/email\r\n       :db/id]])\r\n\r\n(defn update-existing [m k f & args]\r\n  (if (get m k)\r\n    (apply update m k f args)\r\n    m))\r\n\r\n(tests\r\n  (update-existing {:a 1} :a + 10) := {:a 11}\r\n  (update-existing {:a 1} :b + 10) := {:a 1})\r\n\r\n;(defn positional\r\n;  \"Transform an array-like map {0 :foo, 1 :bar, ...} with contiguous array keys (0, 1, ...) into\r\n;   list [:foo :bar]\"\r\n;  [amap]\r\n;  (->> (range (inc (count amap)))\r\n;       (reduce (fn [acc idx]\r\n;                 (if (contains? amap idx)\r\n;                   (conj acc (get amap idx))\r\n;                   (reduced acc)))\r\n;               [])\r\n;       (seq)))\r\n;\r\n;(tests (positional {0 :foo 1 :bar}) := [:foo :bar])\r\n\r\n;; https://github.com/weavejester/medley/blob/master/src/medley/core.cljc\r\n;; https://clojure.atlassian.net/browse/CLJ-1451\r\n(defn take-upto [pred]\r\n  (fn [rf] \r\n    (fn \r\n      ([] (rf))\r\n      ([ac] (rf ac))\r\n      ([ac nx] (cond-> (rf ac nx) (pred nx) ensure-reduced)))))\r\n\r\n(tests\r\n  (into [] (take-upto odd?) [2 4 6 8 9 10 12 14]) := [2 4 6 8 9])\r\n\r\n(defn round-floor [n base] (* base (clojure.math/floor (/ n base))))\r\n\r\n(comment\r\n  \"base 10\"\r\n  (round-floor 89 10) := 80.0\r\n  (round-floor 90 10) := 90.0\r\n  (round-floor 91 10) := 90.0\r\n  (round-floor 99 10) := 90.0\r\n  (round-floor 100 10) := 100.0\r\n  \"base 8\"\r\n  (round-floor 7 8) := 0.0\r\n  (round-floor 8 8) := 8.0\r\n  (round-floor 9 8) := 8.0\r\n  (round-floor 15 8) := 8.0\r\n  (round-floor 16 8) := 16.0\r\n\r\n  (round-floor 1234567 1000) := 1234000.0)\r\n\r\n(defn pad\r\n  ([zero coll] (concat coll (repeat zero)))\r\n  ([n zero coll] (take n (pad zero coll))))\r\n\r\n(defn padl [n zero coll] (concat (repeat (- n (count coll)) zero) coll))\r\n\r\n(tests\r\n  (pad 8 0 (range 3)) := [0 1 2 0 0 0 0 0]\r\n  (padl 8 0 (range 3)) := [0 0 0 0 0 0 1 2]\r\n\r\n  \"strings leak platform internals, use padl-str\"\r\n  (pad 8 \"0\" \"xx\") := #?(:clj [\\x \\x \"0\" \"0\" \"0\" \"0\" \"0\" \"0\"]\r\n                         :cljs [\"x\" \"x\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\"])\r\n\r\n  (padl 8 \"0\" \"xx\") := #?(:clj [\"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \\x \\x]\r\n                          :cljs [\"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"x\" \"x\"]))\r\n\r\n(defn assoc-vec [xs k v]\r\n  (if (>= k (count xs))\r\n    (assoc (vec (pad k nil xs)) k v)\r\n    (assoc xs k v)))\r\n\r\n(tests\r\n  (assoc-vec [] 0 :a) := [:a]\r\n  (assoc-vec [] 1 :b) := [nil :b]\r\n  (assoc-vec [] 4 :e) := [nil nil nil nil :e]\r\n  (assoc-vec nil 4 :e) := [nil nil nil nil :e]\r\n  (assoc-vec [:a :b :c] 1 :B) := [:a :B :c]\r\n  (assoc-vec [:a :b :c] 4 :E) := [:a :b :c nil :E])\r\n\r\n(defn padl-str [n zero s] (apply str (padl n zero s)))\r\n\r\n(tests\r\n  (padl-str 8 \"0\" \"xx\") := \"000000xx\"\r\n  (padl-str 4 \"0\" (str 11)) := \"0011\")\r\n\r\n(defn with-pad [reducer zero]\r\n  (fn [f & cols]\r\n    (let [n (apply max (map count cols))\r\n          cols (map #(pad n zero %) cols)]\r\n      (apply reducer f cols))))\r\n\r\n(def map-pad (partial with-pad map))\r\n\r\n(tests\r\n  (map + [1 1 1] [1 1 1 1]) := '(2 2 2)\r\n  ((map-pad 0) + [1 1 1] [1 1 1 1]) := '(2 2 2 1))\r\n\r\n(defn str-last-n [n s]\r\n  #?(:clj (.substring s (max 0 (- (.length s) n)))\r\n     :cljs (apply str (reverse (take n (reverse s))))))\r\n\r\n(tests\r\n  (str-last-n 4 \"0123456789\") := \"6789\")\r\n\r\n; org.apache.commons.lang3.StringUtils.containsIgnoreCase()\r\n;(defn str-contains-ignore-case [])\r\n\r\n;(defn clamp [n min max] (Math/min (Math/max n min) max))\r\n;\r\n;(tests\r\n;  (clamp 51 10 50) := 50\r\n;  (clamp 50 10 50) := 50\r\n;  (clamp 49 10 50) := 49\r\n;  (clamp 11 10 50) := 11\r\n;  (clamp 10 10 50) := 10\r\n;  (clamp 9  10 50) := 10)\r\n\r\n#?(:clj\r\n   (defmacro orp\r\n     \"`clojure.core/or` evaluates arguments one by one, returning the first truthy\r\n  one and so leaving the remaining ones unevaluated. `orp` does the same but\r\n  with a custom predicate.\"\r\n     ([pred] nil)\r\n     ([pred x]\r\n      `(let [or# ~x]\r\n         (when (~pred or#) or#)))\r\n     ([pred x & next]\r\n      `(let [or# ~x]\r\n         (if (~pred or#) or# (orp ~pred ~@next))))))\r\n\r\n(tests\r\n  (orp some? nil false 1) := false\r\n  (orp even? 1 3 5 6 7) := 6)\r\n\r\n(defn nil-or-empty? [x]\r\n  (if (seqable? x)\r\n    (empty? x)\r\n    (nil? x)))\r\n\r\n(defn- -tree-list [depth xs children-fn keep? input]\r\n  (eduction (mapcat (fn [x]\r\n                      (let [x (datafy x)]\r\n                        (if-let [children (children-fn x)]\r\n                          (when-let [rows (seq (-tree-list (inc depth) children children-fn keep? input))]\r\n                            (into [[depth x]] rows))\r\n                          (cond-> [] (keep? x input) (conj [depth x]))))))\r\n    (datafy xs)))\r\n\r\n(defn treelister\r\n  ([xs] (treelister xs (fn [_]) (fn [_ _] true)))\r\n  ([xs children-fn keep?] (fn [input] (-tree-list 0 xs children-fn keep? input))))\r\n\r\n(tests\r\n  (vec ((treelister [1 2 [3 4] [5 [6 [7]]]] #(when (vector? %) %) (fn [v _] (odd? v))) nil))\r\n  := [[0 1] [0 [3 4]] [1 3] [0 [5 [6 [7]]]] [1 5] [1 [6 [7]]] [2 [7]] [3 7]]\r\n\r\n  ((treelister [{:dir \"x\" :children [{:file \"a\"} {:file \"b\"}]}] :children (fn [v needle] (-> v :file #{needle})) ) \"a\")\r\n  (count (vec *1)) := 2\r\n\r\n  \"directory is omitted if there are no children matching keep?\"\r\n  ((treelister [{:dir \"x\" :children [{:file \"a\"} {:file \"b\"}]}] :children (fn [v needle] (-> v :file #{needle}))) \"nope\")\r\n  (count (vec *1)) := 0)"],"x_google_ignoreList":[0]}